# 截圖與 visual studio 翻編譯的程式碼
## DetectedThread
![[Pasted image 20250308204906.png]]
visual studio 反編譯結果的 error message
- System.InvalidOperationException
  HResult=0x80131509
  Message=集合已修改; 列舉作業可能尚未執行。
  Source=mscorlib
  StackTrace: 
   at System.ThrowHelper.ThrowInvalidOperationException(ExceptionResource resource)
   at System.Collections.Generic.List`1.Enumerator.MoveNextRare()
   at System.Collections.Generic.List`1.Enumerator.MoveNext()
   at KeyboardWar.KeyboardWar.DetectOutScreen() in KeyboardWar\KeyboardWar.cs:line 56
   at KeyboardWar.KeyboardWarForm.<CreateDetectThread>b__7_0() in KeyboardWar\KeyboardWarForm.cs:line 66
   at System.Threading.ThreadHelper.ThreadStart_Context(Object state)
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   at System.Threading.ThreadHelper.ThreadStart()

```csharp
public void DetectOutScreen()
{
	List<Monster> deleteMonsterList = new List<Monster>();
	foreach (Monster j in Monsters)
	{
		if (j.Y + j.Size.Height > (float)windowHeight)
		{
			j.Die();
			score += minusScore;
			MinusScore(j);
			deleteMonsterList.Add(j);
		}
	}
	foreach (Monster i in deleteMonsterList)
	{
		DestoryMonster(i);
	}
}
```

---

## UpdateThread
![[Pasted image 20250308205340.png]]
```csharp
		if (interval > 50f)
		{
			interval -= 1f;
		}
		pictureBox.Invalidate();
		Thread.Sleep((int)physicInterval);
	}
}
```

---

## CreateMonsterThread
![[Pasted image 20250308205547.png]]
```csharp
private void CreateMonsterThread()
{
	Thread thread = new Thread((ThreadStart)delegate
	{
		while (true)
		{
			keyboardWar.CreateMonster();
			Thread.Sleep((int)interval);
		}
	});
	thread.Name = "CreateMonsterThread";
	thread.Start();
}
```
---

### **推論與錯誤分析**

根據 PDF 提供的 **Call Stack** 紀錄和反編譯程式碼，程式在 `DetectThread`內部發生了 **System.InvalidOperationException** 異常。此異常的錯誤訊息為：

> **集合已修改; 列舉作業可能尚未執行。**

這代表在 `foreach` 迴圈 **遍歷 `Monsters` 集合** 的同時，該集合的內容遭到修改，導致 `Enumerator` 無法繼續正常運行。此錯誤在 `System.Collections.Generic.List<T>.Enumerator.MoveNext()` 。

#### **錯誤發生的可能原因**

1. **Concurrent Modification **
    
    - 在 `DetectOutScreen()` 方法中，`foreach` 迴圈正在遍歷 `Monsters` 集合：
        
        ```csharp
        foreach (Monster j in Monsters)
        ```
        
    - 但在迴圈內，某些元素會被加入到 `deleteMonsterList`，並在第二個 `foreach` 迴圈中刪除：
        
        ```csharp
        foreach (Monster i in deleteMonsterList)
        {
            DestoryMonster(i);
        }
        ```
        
    - 假設 `DestroyMonster(i)` 直接影響 `Monsters`（如 `Monsters.Remove(i)`），那麼在原本 `foreach` 迴圈中，**`Monsters` 內容發生變更，導致 `MoveNext()` 出錯**。
2. **Race Condition**
    
    - `CreateMonsterThread()` **不斷新增monster** 至 `Monsters`：
        
        ```csharp
        while (true)
        {
            keyboardWar.CreateMonster();
            Thread.Sleep((int)interval);
        }
        ```
        
    - **`DetectThread` 可能與 `CreateMonsterThread` 同時存取 `Monsters`**，造成未同步處理的競爭條件 (Race Condition)。

#### **可能的解法**

1. **使用 `lock` **
    
    - 在所有涉及 `Monsters` 存取的地方加上 `lock`，確保同一時間只有一個執行緒能修改 `Monsters`：
        
        ```csharp
        private object monsterLock = new object();
        
        public void DetectOutScreen()
        {
            List<Monster> deleteMonsterList = new List<Monster>();
        
            lock (monsterLock)
            {
                foreach (Monster j in Monsters)
                {
                    if (j.Y + j.Size.Height > (float)windowHeight)
                    {
                        j.Die();
                        score += minusScore;
                        MinusScore(j);
                        deleteMonsterList.Add(j);
                    }
                }
        
                foreach (Monster i in deleteMonsterList)
                {
                    DestoryMonster(i);
                }
            }
        }
        ```
        
    - 同樣的，在 `CreateMonsterThread()` 內部 `keyboardWar.CreateMonster();` 之前也應該 `lock (monsterLock)`。

2. **避免在 `foreach` 內修改集合**
    
    - 另一個簡單解法是改用 `for` 迴圈，並在迴圈結束後一次性刪除 `Monsters` 內的對象：
        
        ```csharp
        List<Monster> toRemove = new List<Monster>();
        for (int i = 0; i < Monsters.Count; i++)
        {
            if (Monsters[i].Y + Monsters[i].Size.Height > (float)windowHeight)
            {
                Monsters[i].Die();
                score += minusScore;
                MinusScore(Monsters[i]);
                toRemove.Add(Monsters[i]);
            }
        }
        
        foreach (var m in toRemove)
        {
            DestoryMonster(m);
        }
        ```
        