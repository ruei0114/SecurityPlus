{
	"nodes":[
		{"id":"544a9089c978487e","type":"group","x":3760,"y":-1440,"width":2560,"height":3918,"label":"第三章"},
		{"id":"4e655a42e18362da","type":"group","x":800,"y":-1440,"width":2120,"height":2440,"label":"第二章"},
		{"id":"efa357e5b9e944e3","type":"group","x":-1460,"y":-1440,"width":2033,"height":1840,"label":"第一章"},
		{"id":"c63520efa89a2457","type":"group","x":1460,"y":-1420,"width":1440,"height":2400,"label":"浮點數"},
		{"id":"cdb10722237d98ac","type":"group","x":4080,"y":818,"width":1760,"height":1640,"label":"效能總評"},
		{"id":"3104d47f5a0a75be","type":"group","x":8880,"y":-1286,"width":800,"height":1686,"label":"指令格式"},
		{"id":"f9c18336740762d3","type":"group","x":5520,"y":-422,"width":780,"height":750,"label":"CPU Time"},
		{"id":"128d402ed7099739","type":"file","file":"attachment/byte次方.png","x":-1440,"y":-1420,"width":228,"height":420},
		{"id":"c4c8f56d09db2461","type":"text","text":"# 同步指令\n![[1736063528066.jpg]]\n**1. 初始化與目標數值**\n`try: add $t0, $zero, $s4`\n- 將 `$s4` 的值複製到暫存器 `$t0` 中。\n- `$s4` 可以理解為準備寫入的目標值，這裡先將它保存在 `$t0`，後續會嘗試將其存回記憶體。\n\n---\n\n**2. 載入記憶體的原始值**\n\n`ll $t1, 0($s1)`\n\n- 使用 **`ll`（Load Linked）** 指令，將記憶體位址 `$s1` 指向的值載入到 `$t1`。\n- **`ll`** 還會建立一個標記，用來追蹤這塊記憶體是否在之後被其他程序修改。如果記憶體被干擾，後續的 **`sc`** 操作會失敗。\n\n---\n**3. 嘗試存回記憶體**\n\n`sc $t0, 0($s1)`\n\n- 使用 **`sc`（Store Conditional）** 指令，嘗試將 `$t0` 的值存到 `$s1` 所指向的記憶體位址。\n- 如果自 **`ll`** 以來記憶體內容未被其他程序或執行緒修改，則存取成功，並將 **`sc`** 的結果設為 `1`。\n- 如果記憶體內容被其他程序修改過，則存取失敗，並將 **`sc`** 的結果設為 `0`。\n\n---\n**4. 檢查是否成功**\n\n`beg $t0, $zero, try`\n\n- 檢查 **`sc`** 的結果（儲存在 `$t0` 中）。\n    - 如果 **`sc`** 成功，`$t0 != 0`，跳過這行指令，程式繼續執行後續邏輯。\n    - 如果 **`sc`** 失敗，`$t0 == 0`，則返回標籤 `try`，重新嘗試操作，直到成功為止。\n\n---\n**5. 更新暫存器**\n\n`add $s4, $zero, $t1`\n\n- 將記憶體原始值 `$t1` 儲存回 `$s4`，以便後續程式邏輯使用。\n- 這步的作用是保留讀取到的舊值。","x":-144,"y":-1340,"width":697,"height":1720},
		{"id":"4031d52855903299","type":"file","file":"attachment/MIPS procedure call.png","x":-924,"y":-1420,"width":560,"height":356},
		{"id":"53e4c20c36b879c3","type":"file","file":"attachment/MIPS memory layout.png","x":-1020,"y":-800,"width":520,"height":450},
		{"id":"46e87c718fe81a8f","type":"file","file":"attachment/RISC vs CISC.jpg","x":-1260,"y":-200,"width":672,"height":400},
		{"id":"b9b9468ab9c52ef4","type":"text","text":"1. $$改善後執行時間=\\frac{改善部分元執行時間}{改善倍率}+為改善部分原執行時間$$\n2. $$Speed up \\le\\frac{1}{S+\\frac{1-S}{N}}$$\n$S : 沒改善的部分$\n$N : 改善倍率$\n---\n- $N \\to \\infty, 仍有\\ S\\ 沒有改變$\n- 應專注於改善常出現的部分","x":4616,"y":-698,"width":608,"height":409},
		{"id":"914ff6fe9d5776d8","type":"text","text":"# 常見效能定義\n### **1. 執行時間 (execution time)**\n- 工作開始到完成所花的時間\n- 常用於比較兩部不同個人電腦執行相同程式\n- **本章以執行時間作為效能評估唯一標準**\n\n### 2. 生產量 (throughput)\n- 單位時間內完成的工作量\n- 用於評比多人共用的伺服器","x":4680,"y":-1420,"width":480,"height":391},
		{"id":"057972c6679ef1ea","type":"text","text":"\n|                              | Instr. Count | CPI | Clock Rate |\n| ---------------------------- | ------------ | --- | ---------- |\n| Algorithm                    | ✓            | ✓   |            |\n| Programming Language         | ✓            | ✓   |            |\n| Compiler                     | ✓            | ✓   |            |\n| Instruction Set Architecture | ✓            | ✓   | ✓          |\n| Computer Organization        |              | ✓   | ✓          |\n| VLSI Technology              |              |     | ✓          |\n","x":3780,"y":-1029,"width":545,"height":331},
		{"id":"eb97db9fc446498f","type":"text","text":"# 補數\n## 1's Complement\n1. 表示法\n\t- 所有位元取 not\n\t- $6_{10} = 0110_{2}$, $-6_{10} = 1001_{2}$\n2. 缺點\n\t1. 有 $+0$與 $-0$\n\t2. 端回進位\n\t\t$-3+(-1) = 1100+1100 = 1010 = -5$ **錯**\n\t\t$1010+1=1011=-4$\n---\n## 2's Complement\n1. 表示法\n\t1. 先取 1's Complement\n\t2. 加$1$\n\t\t$6_{10}=0110_{2}$ 的 2's Complement 為\n\t\t$1001_{2}+1_{2}=1010_{2}=-6_{10}$","x":820,"y":-1400,"width":510,"height":680},
		{"id":"b6543498d9417790","type":"text","text":"消費者常希望只靠一個數字來比較效能，稱為效能總評","x":4641,"y":838,"width":498,"height":67},
		{"id":"86fff8612826c965","type":"text","text":"$$\\sqrt[n]{\\prod_{i=1}^nExecution\\ time\\ ratio_i}$$\n- $Execution\\ time\\ ratio_i\\ 為所有\\ n\\ 工作中，第\\ i\\ 個程式針對基準值正規化後的執行時間$ \n---\n1. $$先幾何平均再正規化=先正規化再取幾何平均$$\n$$\\frac{Geometric\\ mean(X_i)}{Geometric\\ mean(Y_i)}=Geometric\\ mean(\\frac{X_i}{Y_i})$$\n2. 分別對 A 或 B 做正規化，幾何平均結果皆相同\n---\n### 幾何平均的正規化\n1. 優\n\t- 與各程式執行時間無關\n\t- 無關取誰作為正規化基準\n1. 缺\n\t- 違背效能量測基本原則，無法預測執行時間","x":5060,"y":1418,"width":760,"height":680},
		{"id":"66ab4a31638493b3","type":"file","file":"attachment/SPECratio.png","x":4620,"y":1038,"width":540,"height":166},
		{"id":"80fccc4c1b9b01ba","type":"text","text":"### 1. 矛盾\n- 對程式 1 而言，A 比 B 快 10 倍\n- 對程式 2 而言，B 比 A 快 10 倍\n### 2. 總評\n1. **使用算術平均**\n$$AM=\\frac{1}{n}\\sum_{i=1}^nTime_i$$\n\t$Time_i : 第 i 個程式執行時間$\n\t$n : 程式總量$\n---\n1. 當每一個程式的執行次數皆不同使用**加權平均**\n\t$$WAM=\\sum_{i=1}^nTime_i\\times Weight_i$$\n### 3. 正規化\n- 同時評量多部機器效能時常會進行正規化，此計算比值稱為 **$SPECratio$**\n\n$$SPECratio=ExTime\\ referenced/ExTime\\ measured$$\n#### 問題\n1. 針對 A 做正規化，算術平均顯示 B 為 A 的 $5.05/1=5.05\\ 倍快$\n2. 針對 B 做正規化，算術平均顯示 A 為 B 的 $5.05/1=5.05\\ 倍快$\n#### 解決方法\n- 採用幾何平均","x":4100,"y":1418,"width":681,"height":1020},
		{"id":"ead0197037d5891c","type":"text","text":"# 公式\n$(-1)^{sign}\\times(1+Fraction)\\times2^{Exponent-Bias}$","x":1480,"y":-1400,"width":420,"height":120},
		{"id":"3703956ecb0e8c77","type":"file","file":"attachment/CPU time.png","x":5543,"y":58,"width":735,"height":250},
		{"id":"14ce44b55a5a40b2","type":"text","text":"```mermaid\ngraph LR\n    A[\"執行一個程式所需時間\\n(流逝時間)\"] -->B[程式執行及等待 I/O 時間] \n    A -->C[程式使用 CPU 時間]\n    C -->D[\"CPU執行作業系統時間\\n(System CPU time)\"]\n    C -->E[\"`**CPU執行使用者程式時間(User CPU Time)**`\"]\n```\n**本章只關注 User CPU Time**","x":5540,"y":-402,"width":740,"height":340},
		{"id":"cd918c8220e96665","type":"text","text":"$$Performance_X = \\frac{1}{Execution\\ Time_X}$$\n### Example\n- machine A 執行一程式需 $10\\ second$\n- machine B 執行一程式需 $15\\ second$\n\t問: A 比 B 快多少\n\t$$\\frac{Performance_A}{Performance_B}=\\frac{Execution\\ time_B}{Execution\\ time_A}=\\frac{15}{10}=1.5$$","x":5540,"y":-1089,"width":490,"height":391},
		{"id":"ecd018fc634c7cc0","type":"text","text":"## 二進位浮點數轉十進位\n\n假設浮點數為：\n\n$$0 10000010 010011000000000000000000$$\n\n#### 步驟：\n\n1. **拆解浮點數：**\n    \n    - 符號位 $S=0$ ：正數\n    - 指數位 $E=10000010_{2}=130$ ：實際指數 $n=130−127=3$\n    - 尾數位 $F=010011$ ：有效數字為 $1.010011$\n2. **計算數值：**\n    \n    $$值=(+1)×1.010011×2^3=1010.011_2$$\n3. **轉十進位：**\n    \n    - 整數部分：$1010_2=10_10$\n    - 小數部分：$011_2=0.375_10$\n\n結果為：\n\n$$值=10.375_10$$","x":1480,"y":-700,"width":620,"height":620},
		{"id":"2a480e4248a43b19","type":"text","text":"# 非正規化數\n\n| **指數位 (EEE)** | **尾數位 (FFF)** | **符號位 (SSS)** | **表示意義**  |\n| ------------- | ------------- | ------------- | --------- |\n| 00000000      | 000...0       | 0             | +0        |\n| 00000000      | 000...0       | 1             | -0        |\n| 00000000      | 非全 0          | 0 或 1         | 次規範數      |\n| 11111111      | 000...0       | 0             | +Infinity |\n| 11111111      | 000...0       | 1             | -Infinity |\n| 11111111      | 非全 0          | 0 或 1         | NaN (非數值) |","x":1480,"y":-1100,"width":540,"height":340},
		{"id":"57d1bea1a9c2ce2d","type":"text","text":"## 十進位數轉二進位浮點數\n### 步驟 1：判斷符號位\n\n- **十進位數值：** $10.375$\n- **判斷符號：** 數值為正，符號位 $S=0$\n\n---\n\n### 步驟 2：將十進位數轉換為二進位\n\n將數值拆分為整數部分和小數部分進行轉換。\n\n#### **整數部分轉二進位：**\n\n整數部分為 $10$，使用「除 $2$ 取餘數」法：\n\n1. $10÷2=5$ 餘 $0$\n2. $5÷2=2$ 餘 $1$\n3. $2÷2=1$ 餘 $0$\n4. $1÷2=0$ 餘 $1$\n\n從下往上讀餘數：$10_{10}=1010_{2}$\n\n#### **小數部分轉二進位：**\n\n小數部分為 $0.375$，使用「乘 $2$ 取整數」法：\n\n1. $0.375×2=0.75$ 取整數 $0$\n2. $0.75×2=1.5$ 取整數 $1$\n3. $0.5×2=1.0$ 取整數 $1$\n\n小數部分為 $0.375_{10}=011_{2}$\n\n---\n\n#### **整數 + 小數結果：**\n\n將整數與小數部分合併：\n\n$$10.375_{10}=1010.011_{2}$$\n\n---\n\n### 步驟 3：正規化二進位數\n\n將二進位數表示為 1. $fraction×2^n$ 的形式：\n- $1010.011_{2}=1.010011×2^3$\n- **尾數部分：** $1.010011$（隱含 $1.$）\n- **指數值：** $n=3$\n\n---\n\n### 步驟 4：計算指數位\n\n指數位以偏移值 $127$ 表示：\n\n$$指數位=127+n=127+3=130$$\n\n將 $130$ 轉為二進位：\n\n$$130_{10}=10000010_{2}$$\n指數位為：$10000010$\n\n---\n\n### 步驟 5：填寫尾數位\n\n尾數部分來自正規化後的 $1.010011$，隱含的 $1.$ 不計入，只保留小數部分 $010011$，並補零至 $23$ 位：\n\n$$尾數位=01001100000000000000000$$\n---\n\n### 步驟 6：組合成浮點數格式\n\n將符號位、指數位、尾數位組合：\n\n$$最終結果=0 10000010 01001100000000000000000$$","x":2180,"y":-1340,"width":660,"height":2232},
		{"id":"4f62c07d88231bc8","type":"file","file":"attachment/Pasted image 20250126163752.png","x":11440,"y":-1320,"width":1060,"height":738},
		{"id":"4a91e20711ea51f5","type":"text","text":"### R-Type 指令\n\n格式：`op rd, rs, rt` 或其他變形\n\n- **add**：`add rd, rs, rt`\n- **sub**：`sub rd, rs, rt`\n- **and**：`and rd, rs, rt`\n- **or**：`or rd, rs, rt`\n- **slt**：`slt rd, rs, rt`\n- **sll**（邏輯左移）：`sll rd, rt, shamt`\n- **srl**（邏輯右移）：`srl rd, rt, shamt`\n- **jr**（跳回暫存器）：`jr rs`\n- **mult**：`mult rs, rt`\n- **div**：`div rs, rt`\n\n---\n\n### I-Type 指令\n\n格式：`op rt, imme(rs)` 或 `op rt, rs, imme`\n\n- **lw**（載入字）：`lw rt, imme(rs)`\n- **sw**（儲存字）：`sw rt, imme(rs)`\n- **addi**：`addi rt, rs, imme`\n- **andi**：`andi rt, rs, imme`\n- **ori**：`ori rt, rs, imme`\n- **slti**：`slti rt, rs, imme`\n- **beq**（相等條件分支）：`beq rs, rt, label`\n- **bne**（不等條件分支）：`bne rs, rt, label`\n- **lui**（載入高位立即數）：`lui rt, imme`\n\n---\n\n### J-Type 指令\n\n格式：`op target`\n\n- **j**（無條件跳躍）：`j label`\n- **jal**（跳躍並儲存返回地址）：`jal label`\n\n---\n\n### **補充說明**\n\n1. **R-Type** 指令的操作主要在 **寄存器之間**，沒有立即數，結果通常寫回到 `rd`。\n2. **I-Type** 指令的操作包括 **立即數或記憶體位址**，目標通常是 `rt`。\n3. **J-Type** 指令直接執行跳躍，透過目標位址 `label` 指定跳躍位置。\n\n","x":8900,"y":-977,"width":712,"height":1337},
		{"id":"949e5c979e944cc1","type":"file","file":"attachment/Type Table.png","x":9011,"y":-1266,"width":490,"height":289},
		{"id":"47ffd39e4667df33","type":"file","file":"attachment/datapath.png","x":9720,"y":-1266,"width":800,"height":484}
	],
	"edges":[
		{"id":"71e3aea256f05415","fromNode":"914ff6fe9d5776d8","fromSide":"right","toNode":"cd918c8220e96665","toSide":"left","label":"效能計算"},
		{"id":"cefe784c4071a1ca","fromNode":"14ce44b55a5a40b2","fromSide":"bottom","toNode":"3703956ecb0e8c77","toSide":"top"},
		{"id":"da49a635972a3de9","fromNode":"914ff6fe9d5776d8","fromSide":"left","toNode":"057972c6679ef1ea","toSide":"right","label":"軟硬體效能影響"},
		{"id":"df40143317ca83d5","fromNode":"cd918c8220e96665","fromSide":"bottom","toNode":"f9c18336740762d3","toSide":"top"},
		{"id":"b53935367fe22771","fromNode":"914ff6fe9d5776d8","fromSide":"bottom","toNode":"b9b9468ab9c52ef4","toSide":"top","label":"Amdahl's law"},
		{"id":"39e725c6edb93b46","fromNode":"66ab4a31638493b3","fromSide":"bottom","toNode":"80fccc4c1b9b01ba","toSide":"top","label":"算術平均"},
		{"id":"bb066064ffe559c1","fromNode":"66ab4a31638493b3","fromSide":"bottom","toNode":"86fff8612826c965","toSide":"top","label":"幾何平均"},
		{"id":"d7856b244cdf4037","fromNode":"b6543498d9417790","fromSide":"bottom","toNode":"66ab4a31638493b3","toSide":"top"},
		{"id":"60a0af66217ef94b","fromNode":"b9b9468ab9c52ef4","fromSide":"bottom","toNode":"cdb10722237d98ac","toSide":"top"},
		{"id":"75d891d01aaebba1","fromNode":"3703956ecb0e8c77","fromSide":"bottom","toNode":"cdb10722237d98ac","toSide":"top"},
		{"id":"3773d74decacb4b8","fromNode":"057972c6679ef1ea","fromSide":"bottom","toNode":"cdb10722237d98ac","toSide":"top"}
	]
}